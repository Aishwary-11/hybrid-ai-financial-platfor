#!/usr/bin/env python3
"""
Advanced Orchestration and Routing System - Complete Demo
BlackRock Aladdin-inspired intelligent workflow management and model coordination
"""

import asyncio
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, Any, List

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Import our modules
from app.core.hybrid_ai_engine import HybridAIEngine, TaskCategory
from app.core.advanced_orchestration import (
    create_advanced_orchestration_system,
    WorkflowType, ExecutionStrategy, RoutingDecision,
    WorkflowNode, WorkflowDefinition, RoutingRule
)

class AdvancedOrchestrationDemo:
    """Comprehensive demo of the advanced orchestration system"""
    
    def __init__(self):
        self.ai_engine = None
        self.workflow_engine = None
        self.intelligent_router = None
        self.workflow_builder = None
        
    async def initialize(self):
        """Initialize the orchestration system"""
        
        print(\"\\n\" + \"=\"*80)
        print(\"ADVANCED ORCHESTRATION & ROUTING SYSTEM DEMO\")
        print(\"BlackRock Aladdin-inspired Intelligent Workflow Management\")
        print(\"=\"*80)\n        \n        # Initialize AI engine\n        print(\"\\nüîß Initializing Hybrid AI Engine...\")\n        self.ai_engine = HybridAIEngine()\n        await self.ai_engine.initialize()\n        \n        # Create orchestration system\n        print(\"üîß Creating Advanced Orchestration System...\")\n        self.workflow_engine, self.intelligent_router, self.workflow_builder = \\\n            create_advanced_orchestration_system(self.ai_engine)\n        \n        print(\"‚úÖ System initialized successfully!\")\n    \n    async def demo_intelligent_routing(self):\n        \"\"\"Demonstrate intelligent routing capabilities\"\"\"\n        \n        print(\"\\n\" + \"-\"*60)\n        print(\"üß† INTELLIGENT ROUTING DEMONSTRATION\")\n        print(\"-\"*60)\n        \n        # Test different routing scenarios\n        routing_scenarios = [\n            {\n                \"name\": \"High Priority Request\",\n                \"task_category\": TaskCategory.RISK_ASSESSMENT,\n                \"input_data\": {\"text\": \"Analyze market volatility risks\"},\n                \"context\": {\"priority\": 9, \"deadline\": datetime.now() + timedelta(minutes=5)}\n            },\n            {\n                \"name\": \"Cost-Conscious Request\",\n                \"task_category\": TaskCategory.SENTIMENT_ANALYSIS,\n                \"input_data\": {\"text\": \"Market sentiment looks positive\"},\n                \"context\": {\"priority\": 3, \"budget_constraint\": 0.03}\n            },\n            {\n                \"name\": \"Quality-Critical Request\",\n                \"task_category\": TaskCategory.EARNINGS_PREDICTION,\n                \"input_data\": {\"company\": \"AAPL\", \"quarter\": \"Q4 2024\"},\n                \"context\": {\"priority\": 7, \"quality_requirements\": {\"min_accuracy\": 0.9}}\n            }\n        ]\n        \n        for scenario in routing_scenarios:\n            print(f\"\\nüìç Testing: {scenario['name']}\")\n            print(f\"   Task: {scenario['task_category'].value}\")\n            print(f\"   Context: {scenario['context']}\")\n            \n            try:\n                routing_decision = await self.intelligent_router.route_request(\n                    scenario[\"task_category\"],\n                    scenario[\"input_data\"],\n                    scenario[\"context\"]\n                )\n                \n                print(f\"   ‚úÖ Routing Decision: {routing_decision['routing_decision']}\")\n                print(f\"   üéØ Selected Model: {routing_decision['target_model']}\")\n                print(f\"   üìù Reason: {routing_decision['routing_reason']}\")\n                print(f\"   üé≤ Confidence: {routing_decision['confidence']:.2f}\")\n                \n            except Exception as e:\n                print(f\"   ‚ùå Routing failed: {e}\")\n    \n    async def demo_workflow_templates(self):\n        \"\"\"Demonstrate workflow template system\"\"\"\n        \n        print(\"\\n\" + \"-\"*60)\n        print(\"üìã WORKFLOW TEMPLATE DEMONSTRATION\")\n        print(\"-\"*60)\n        \n        # Show available templates\n        templates = self.workflow_builder.get_available_templates()\n        print(f\"\\nüìö Available Templates: {len(templates)}\")\n        \n        for template_name in templates:\n            template_info = self.workflow_builder.get_template_info(template_name)\n            print(f\"\\n  üìÑ {template_info['name']}\")\n            print(f\"     Description: {template_info['description']}\")\n            print(f\"     Type: {template_info['workflow_type']}\")\n            print(f\"     Nodes: {template_info['node_count']} ({', '.join(template_info['node_types'])})\")\n        \n        # Create and register workflows from templates\n        print(\"\\nüèóÔ∏è Creating workflows from templates...\")\n        \n        for template_name in templates:\n            try:\n                workflow = self.workflow_builder.create_workflow_from_template(template_name)\n                self.workflow_engine.register_workflow(workflow)\n                print(f\"   ‚úÖ Created and registered: {workflow.name}\")\n            except Exception as e:\n                print(f\"   ‚ùå Failed to create {template_name}: {e}\")\n    \n    async def demo_sequential_workflow(self):\n        \"\"\"Demonstrate sequential workflow execution\"\"\"\n        \n        print(\"\\n\" + \"-\"*60)\n        print(\"üîÑ SEQUENTIAL WORKFLOW DEMONSTRATION\")\n        print(\"-\"*60)\n        \n        # Find sequential workflow\n        sequential_workflow_id = None\n        for workflow_id, workflow in self.workflow_engine.workflows.items():\n            if workflow.workflow_type == WorkflowType.SEQUENTIAL:\n                sequential_workflow_id = workflow_id\n                break\n        \n        if not sequential_workflow_id:\n            print(\"‚ùå No sequential workflow found\")\n            return\n        \n        print(f\"\\nüöÄ Executing Sequential Workflow: {sequential_workflow_id}\")\n        \n        # Test data\n        test_data = {\n            \"text\": \"Apple's Q4 earnings exceeded expectations with strong iPhone sales, but supply chain concerns remain.\",\n            \"company\": \"AAPL\",\n            \"sector\": \"Technology\"\n        }\n        \n        print(f\"üìä Input Data: {test_data}\")\n        \n        try:\n            start_time = datetime.now()\n            result = await self.workflow_engine.execute_workflow(\n                sequential_workflow_id,\n                test_data,\n                user_context={\"user_id\": \"demo_user\", \"session_id\": \"demo_session\"},\n                execution_parameters={\"priority\": 5, \"timeout\": 180}\n            )\n            execution_time = (datetime.now() - start_time).total_seconds()\n            \n            print(f\"\\n‚úÖ Workflow completed in {execution_time:.2f} seconds\")\n            print(f\"üìã Status: {result['status']}\")\n            print(f\"üî¢ Nodes executed: {result['nodes_executed']}\")\n            print(f\"‚è±Ô∏è Execution time: {result['execution_time']:.2f}s\")\n            \n            if 'result' in result:\n                print(f\"\\nüìä Workflow Results:\")\n                self._print_nested_dict(result['result'], indent=2)\n            \n            if 'performance_metrics' in result:\n                print(f\"\\nüìà Performance Metrics:\")\n                self._print_nested_dict(result['performance_metrics'], indent=2)\n                \n        except Exception as e:\n            print(f\"‚ùå Workflow execution failed: {e}\")\n    \n    async def demo_parallel_ensemble_workflow(self):\n        \"\"\"Demonstrate parallel ensemble workflow\"\"\"\n        \n        print(\"\\n\" + \"-\"*60)\n        print(\"üîÄ PARALLEL ENSEMBLE WORKFLOW DEMONSTRATION\")\n        print(\"-\"*60)\n        \n        # Find ensemble workflow\n        ensemble_workflow_id = None\n        for workflow_id, workflow in self.workflow_engine.workflows.items():\n            if workflow.workflow_type == WorkflowType.ENSEMBLE:\n                ensemble_workflow_id = workflow_id\n                break\n        \n        if not ensemble_workflow_id:\n            print(\"‚ùå No ensemble workflow found\")\n            return\n        \n        print(f\"\\nüöÄ Executing Parallel Ensemble Workflow: {ensemble_workflow_id}\")\n        \n        # Test data for sentiment analysis\n        test_data = {\n            \"text\": \"The Federal Reserve's decision to maintain interest rates has created mixed reactions in the market. While some investors see this as a sign of economic stability, others worry about potential inflationary pressures.\",\n            \"context\": \"financial_news\"\n        }\n        \n        print(f\"üìä Input Data: {test_data['text'][:100]}...\")\n        \n        try:\n            start_time = datetime.now()\n            result = await self.workflow_engine.execute_workflow(\n                ensemble_workflow_id,\n                test_data,\n                user_context={\"analysis_type\": \"market_sentiment\"},\n                execution_parameters={\"priority\": 6, \"require_consensus\": True}\n            )\n            execution_time = (datetime.now() - start_time).total_seconds()\n            \n            print(f\"\\n‚úÖ Ensemble workflow completed in {execution_time:.2f} seconds\")\n            print(f\"üìã Status: {result['status']}\")\n            print(f\"üî¢ Models executed: {result['nodes_executed']}\")\n            \n            if 'result' in result:\n                print(f\"\\nüéØ Ensemble Results:\")\n                self._print_nested_dict(result['result'], indent=2)\n                \n        except Exception as e:\n            print(f\"‚ùå Ensemble workflow execution failed: {e}\")\n    \n    async def demo_adaptive_workflow(self):\n        \"\"\"Demonstrate adaptive workflow execution\"\"\"\n        \n        print(\"\\n\" + \"-\"*60)\n        print(\"üß† ADAPTIVE WORKFLOW DEMONSTRATION\")\n        print(\"-\"*60)\n        \n        # Find adaptive workflow\n        adaptive_workflow_id = None\n        for workflow_id, workflow in self.workflow_engine.workflows.items():\n            if workflow.workflow_type == WorkflowType.ADAPTIVE:\n                adaptive_workflow_id = workflow_id\n                break\n        \n        if not adaptive_workflow_id:\n            print(\"‚ùå No adaptive workflow found\")\n            return\n        \n        print(f\"\\nüöÄ Executing Adaptive Workflow: {adaptive_workflow_id}\")\n        \n        # Test scenarios with different confidence levels\n        test_scenarios = [\n            {\n                \"name\": \"High Confidence Scenario\",\n                \"data\": {\n                    \"text\": \"Tesla reports record quarterly profits with strong EV sales growth\",\n                    \"confidence_hint\": \"high\"\n                }\n            },\n            {\n                \"name\": \"Low Confidence Scenario\",\n                \"data\": {\n                    \"text\": \"Market conditions remain uncertain with mixed signals\",\n                    \"confidence_hint\": \"low\"\n                }\n            }\n        ]\n        \n        for scenario in test_scenarios:\n            print(f\"\\nüìä Testing: {scenario['name']}\")\n            print(f\"   Data: {scenario['data']['text'][:80]}...\")\n            \n            try:\n                start_time = datetime.now()\n                result = await self.workflow_engine.execute_workflow(\n                    adaptive_workflow_id,\n                    scenario[\"data\"],\n                    user_context={\"scenario\": scenario[\"name\"]},\n                    execution_parameters={\"priority\": 7, \"adaptive_threshold\": 0.8}\n                )\n                execution_time = (datetime.now() - start_time).total_seconds()\n                \n                print(f\"   ‚úÖ Completed in {execution_time:.2f}s\")\n                print(f\"   üìã Status: {result['status']}\")\n                print(f\"   üõ§Ô∏è Execution path: {len(result.get('result', {}).get('execution_summary', {}).get('executed_nodes', 0))} nodes\")\n                \n            except Exception as e:\n                print(f\"   ‚ùå Adaptive workflow failed: {e}\")\n    \n    async def demo_custom_workflow_creation(self):\n        \"\"\"Demonstrate custom workflow creation\"\"\"\n        \n        print(\"\\n\" + \"-\"*60)\n        print(\"üõ†Ô∏è CUSTOM WORKFLOW CREATION DEMONSTRATION\")\n        print(\"-\"*60)\n        \n        # Create a custom financial analysis workflow\n        custom_workflow_spec = {\n            \"name\": \"Custom Financial Analysis Pipeline\",\n            \"description\": \"Custom workflow for comprehensive financial analysis\",\n            \"workflow_type\": \"pipeline\",\n            \"execution_strategy\": \"best_effort\",\n            \"nodes\": [\n                {\n                    \"node_id\": \"data_validation\",\n                    \"node_type\": \"transformer\",\n                    \"parameters\": {\n                        \"type\": \"filter\",\n                        \"criteria\": {\"required_keys\": [\"company\", \"financial_data\"]}\n                    },\n                    \"dependencies\": [],\n                    \"conditions\": [],\n                    \"timeout_seconds\": 30,\n                    \"retry_count\": 1\n                },\n                {\n                    \"node_id\": \"risk_analysis\",\n                    \"node_type\": \"model\",\n                    \"task_category\": \"risk_assessment\",\n                    \"model_name\": \"risk_prediction\",\n                    \"parameters\": {\"analysis_depth\": \"comprehensive\"},\n                    \"dependencies\": [\"data_validation\"],\n                    \"conditions\": [],\n                    \"timeout_seconds\": 90,\n                    \"retry_count\": 2\n                },\n                {\n                    \"node_id\": \"earnings_forecast\",\n                    \"node_type\": \"model\",\n                    \"task_category\": \"earnings_prediction\",\n                    \"model_name\": \"earnings_analysis\",\n                    \"parameters\": {\"forecast_horizon\": \"quarterly\"},\n                    \"dependencies\": [\"risk_analysis\"],\n                    \"conditions\": [\n                        {\n                            \"type\": \"confidence_threshold\",\n                            \"source_node\": \"risk_analysis\",\n                            \"threshold\": 0.6\n                        }\n                    ],\n                    \"timeout_seconds\": 120,\n                    \"retry_count\": 1\n                },\n                {\n                    \"node_id\": \"final_aggregation\",\n                    \"node_type\": \"aggregator\",\n                    \"parameters\": {\n                        \"method\": \"comprehensive_summary\",\n                        \"include_confidence_scores\": True\n                    },\n                    \"dependencies\": [\"risk_analysis\", \"earnings_forecast\"],\n                    \"conditions\": [],\n                    \"timeout_seconds\": 30,\n                    \"retry_count\": 0\n                }\n            ],\n            \"global_timeout_seconds\": 300,\n            \"max_retries\": 2,\n            \"tags\": [\"financial\", \"custom\", \"pipeline\"]\n        }\n        \n        print(\"\\nüèóÔ∏è Creating custom workflow...\")\n        print(f\"   Name: {custom_workflow_spec['name']}\")\n        print(f\"   Type: {custom_workflow_spec['workflow_type']}\")\n        print(f\"   Nodes: {len(custom_workflow_spec['nodes'])}\")\n        \n        try:\n            custom_workflow = self.workflow_builder.create_custom_workflow(custom_workflow_spec)\n            self.workflow_engine.register_workflow(custom_workflow)\n            \n            print(f\"   ‚úÖ Custom workflow created: {custom_workflow.workflow_id}\")\n            \n            # Test the custom workflow\n            print(\"\\nüß™ Testing custom workflow...\")\n            \n            test_data = {\n                \"company\": \"MSFT\",\n                \"financial_data\": {\n                    \"revenue\": 211.9,  # billions\n                    \"net_income\": 72.4,\n                    \"debt_to_equity\": 0.35,\n                    \"current_ratio\": 1.8\n                },\n                \"market_context\": \"tech_sector_analysis\"\n            }\n            \n            result = await self.workflow_engine.execute_workflow(\n                custom_workflow.workflow_id,\n                test_data,\n                user_context={\"analysis_type\": \"comprehensive\"},\n                execution_parameters={\"priority\": 6}\n            )\n            \n            print(f\"   ‚úÖ Custom workflow executed successfully\")\n            print(f\"   üìã Status: {result['status']}\")\n            print(f\"   ‚è±Ô∏è Execution time: {result['execution_time']:.2f}s\")\n            \n        except Exception as e:\n            print(f\"   ‚ùå Custom workflow creation/execution failed: {e}\")\n    \n    async def demo_performance_monitoring(self):\n        \"\"\"Demonstrate performance monitoring and optimization\"\"\"\n        \n        print(\"\\n\" + \"-\"*60)\n        print(\"üìä PERFORMANCE MONITORING DEMONSTRATION\")\n        print(\"-\"*60)\n        \n        # Get system status\n        system_status = self.workflow_engine.get_system_status()\n        print(f\"\\nüñ•Ô∏è System Status:\")\n        print(f\"   Total Workflows: {system_status['total_workflows']}\")\n        print(f\"   Active Executions: {system_status['active_executions']}\")\n        print(f\"   Total Executions: {system_status['execution_stats']['total_executions']}\")\n        print(f\"   Success Rate: {system_status['execution_stats']['avg_success_rate']:.2%}\")\n        print(f\"   Avg Execution Time: {system_status['execution_stats']['avg_execution_time']:.2f}s\")\n        \n        # Get routing statistics\n        routing_stats = self.intelligent_router.get_routing_stats()\n        print(f\"\\nüß† Routing Statistics:\")\n        print(f\"   Total Rules: {routing_stats['total_rules']}\")\n        print(f\"   Active Rules: {routing_stats['active_rules']}\")\n        print(f\"   Tracked Models: {routing_stats['tracked_models']}\")\n        \n        # Show workflow statuses\n        print(f\"\\nüìã Individual Workflow Status:\")\n        for workflow_id in self.workflow_engine.workflows.keys():\n            status = self.workflow_engine.get_workflow_status(workflow_id)\n            print(f\"   {status['name']}:\")\n            print(f\"     Type: {status['workflow_type']}\")\n            print(f\"     Nodes: {status['node_count']}\")\n            print(f\"     Executions: {status['total_executions']}\")\n            print(f\"     Success Rate: {status['success_rate']:.2%}\")\n    \n    async def demo_error_handling_and_fallbacks(self):\n        \"\"\"Demonstrate error handling and fallback mechanisms\"\"\"\n        \n        print(\"\\n\" + \"-\"*60)\n        print(\"üõ°Ô∏è ERROR HANDLING & FALLBACK DEMONSTRATION\")\n        print(\"-\"*60)\n        \n        # Create a workflow with intentional failure points\n        error_test_spec = {\n            \"name\": \"Error Handling Test Workflow\",\n            \"description\": \"Workflow designed to test error handling and fallbacks\",\n            \"workflow_type\": \"sequential\",\n            \"execution_strategy\": \"retry_on_failure\",\n            \"nodes\": [\n                {\n                    \"node_id\": \"unreliable_node\",\n                    \"node_type\": \"model\",\n                    \"task_category\": \"general\",\n                    \"model_name\": \"nonexistent_model\",  # This will fail\n                    \"parameters\": {},\n                    \"dependencies\": [],\n                    \"conditions\": [],\n                    \"timeout_seconds\": 30,\n                    \"retry_count\": 2,\n                    \"fallback_nodes\": [\"fallback_node\"]\n                },\n                {\n                    \"node_id\": \"fallback_node\",\n                    \"node_type\": \"model\",\n                    \"task_category\": \"general\",\n                    \"model_name\": \"general\",  # This should work\n                    \"parameters\": {},\n                    \"dependencies\": [],\n                    \"conditions\": [],\n                    \"timeout_seconds\": 60,\n                    \"retry_count\": 1\n                }\n            ]\n        }\n        \n        print(\"\\nüß™ Creating error handling test workflow...\")\n        \n        try:\n            error_workflow = self.workflow_builder.create_custom_workflow(error_test_spec)\n            self.workflow_engine.register_workflow(error_workflow)\n            \n            print(f\"   ‚úÖ Error test workflow created: {error_workflow.workflow_id}\")\n            \n            # Execute the workflow to test error handling\n            print(\"\\nüî• Testing error handling with intentional failure...\")\n            \n            result = await self.workflow_engine.execute_workflow(\n                error_workflow.workflow_id,\n                {\"text\": \"Test error handling\"},\n                execution_parameters={\"priority\": 5}\n            )\n            \n            print(f\"   üìã Final Status: {result['status']}\")\n            print(f\"   ‚è±Ô∏è Execution Time: {result['execution_time']:.2f}s\")\n            \n            if result['status'] == 'completed':\n                print(\"   ‚úÖ Fallback mechanism worked successfully!\")\n            else:\n                print(f\"   ‚ö†Ô∏è Workflow failed: {result.get('error', 'Unknown error')}\")\n                \n        except Exception as e:\n            print(f\"   ‚ùå Error handling test failed: {e}\")\n    \n    def _print_nested_dict(self, data: Dict[str, Any], indent: int = 0):\n        \"\"\"Helper method to print nested dictionaries\"\"\"\n        \n        prefix = \"  \" * indent\n        \n        if isinstance(data, dict):\n            for key, value in data.items():\n                if isinstance(value, (dict, list)):\n                    print(f\"{prefix}{key}:\")\n                    self._print_nested_dict(value, indent + 1)\n                else:\n                    print(f\"{prefix}{key}: {value}\")\n        elif isinstance(data, list):\n            for i, item in enumerate(data):\n                print(f\"{prefix}[{i}]:\")\n                self._print_nested_dict(item, indent + 1)\n        else:\n            print(f\"{prefix}{data}\")\n    \n    async def run_complete_demo(self):\n        \"\"\"Run the complete demonstration\"\"\"\n        \n        try:\n            await self.initialize()\n            \n            # Run all demonstrations\n            await self.demo_intelligent_routing()\n            await self.demo_workflow_templates()\n            await self.demo_sequential_workflow()\n            await self.demo_parallel_ensemble_workflow()\n            await self.demo_adaptive_workflow()\n            await self.demo_custom_workflow_creation()\n            await self.demo_performance_monitoring()\n            await self.demo_error_handling_and_fallbacks()\n            \n            print(\"\\n\" + \"=\"*80)\n            print(\"üéâ ADVANCED ORCHESTRATION DEMO COMPLETED SUCCESSFULLY!\")\n            print(\"=\"*80)\n            print(\"\\nüìã Summary of Demonstrated Features:\")\n            print(\"   ‚úÖ Intelligent routing with multiple strategies\")\n            print(\"   ‚úÖ Workflow templates and custom workflow creation\")\n            print(\"   ‚úÖ Sequential, parallel, ensemble, and adaptive execution\")\n            print(\"   ‚úÖ Performance monitoring and optimization\")\n            print(\"   ‚úÖ Error handling and fallback mechanisms\")\n            print(\"   ‚úÖ Load balancing and cost optimization\")\n            print(\"   ‚úÖ Quality-based model selection\")\n            \n            print(\"\\nüöÄ The Advanced Orchestration System is ready for production use!\")\n            \n        except Exception as e:\n            print(f\"\\n‚ùå Demo failed with error: {e}\")\n            logger.exception(\"Demo execution failed\")\n\n\nasync def main():\n    \"\"\"Main function to run the advanced orchestration demo\"\"\"\n    \n    demo = AdvancedOrchestrationDemo()\n    await demo.run_complete_demo()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n